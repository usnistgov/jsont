"""
transforms for creating XML from JSON data
"""
import os, json, copy, re

from ..exceptions import *
from ..base import Transform, ScopedDict
from .std import JSON, Extract

MODULE_NAME = __name__
TRANSFORMS_PKG = __name__.rsplit('.', 1)[0]

class ElementContent(object):
    """
    a representation of complex element content including an element's 
    attributes and children (but not it's name).  It's data is packaged
    as JSON data.
    """

    def __init__(self, data=None):
        self.data = data
        if self.data is None:
            self.data = {}

    @property
    def attributes(self):
        if not self.data.has_key('attrs'):
            self.data['attrs'] = []
        return self.data['attrs']

    def add_attribute(self, attr):
        """
        append an attribute definition
        """
        self.attributes.append(attr)

class Attribute(object):
    """
    a representation of an XML attribute.  It's data is packaged
    as JSON data.
    """

    def __init__(self, data):
        if data is None:
            raise ValueError("None provided as attribute data")
        self.data = data

        missing = []
        for prop in "name value".split():
            if prop not in self.data:
                missing.append(prop)
        if len(missing) > 0:
            raise ValueError("dictionary contents does not look like an " +
                             "attribute (missing " + str(missing) + 
                             "): "+str(self.data))

    @classmethod
    def create(cls, name, value, prefix=None, ns=None):
        data = {"name": name, "value": value }
        if prefix is not None:
            data['prefix'] = prefix
        if ns is not None:
            data['namespace'] = ns

        return cls(data)

############

def _generate_name(spec, engine, tname=None, ttype=None):
    return _generate_value(spec, engine, tname, ttype, True)

def _generate_value(spec, engine, tname=None, ttype=None, forname=False):
    if spec is None:
        return None

    if not forname and (isinstance(spec, int) or isinstance(spec, float) or \
                        isinstance(spec, bool)):
        return spec

    if isinstance(spec, dict):
        if spec.has_key('$val'):
            spec = spec['$val']

        if isinstance(spec, dict):
            return engine.make_transform(spec)

        if isinstance(spec, str) or isinstance(spec, unicode):
            if spec == '' or ':' in spec or spec.startswith('/'):
                return Extract({'select': spec}, engine, tname, ttype)

            return engine.resolve_transform(spec)
        else:
            raise TransformConfigTypeError("spec", "string or object",
                                           type(spec), self.spec)

    if isinstance(spec, str) or isinstance(spec, unicode):
        if '{' in spec and '}' in spec:
            # it's a string template
            return StringTemplate({'content': spec}, engine, 
                                  (self.spec or 'attr')+" spec", 
                                  "xml.attribute")
    else:
        raise TransformConfigTypeError("spec", "string or object",
                                       type(spec), self.spec)

    return spec

def _generate_object(spec, engine, tname=None, ttype=None):
    if spec is None:
        return None

    if isinstance(spec, dict):
        # it's an object, either a transform or JSON template
        if not spec.has_key('$val'):
            # it's a JSON template
            return JSON({'content': spec}, engine, tname, ttype)
        else:
            spec = spec["$val"]

    if isinstance(spec, dict):
        # it's an anonymous transform
        return engine.make_transform(spec)

    if isinstance(spec, str) or isinstance(spec, unicode):
        if spec == '' or ':' in spec or spec.startswith('/'):
            # it's a data pointer to select data
            return Extract({'select': spec}, engine, tname, ttype)

        # it's a named transform or transform function
        return engine.resolve_transform(spec)

    return spec



class ToAttribute(Transform):
    """
    a transform type for creating XML Attribute data.  This transform type
    takes the following paramters:

    :argument name:  the local name for the attribute.  If provided as a 
                     string (with { and } characters), it will be treated
                     as a StringTemplate.  If provided as an object with a 
                     $val property, the name will be generated by the transform
                     implied by the $val property value.  Any other kind of 
                     object will be treated as an anonymous transform that 
                     should produce a string value to provide the value of the 
                     name.  
    :argument value:
    :argument namespace:
    :argument prefix:
    """

    def mkfn(self, config, engine):
        tname = self.name or '(xml)'
        ttype = "xml.attribute"

        try:
            name = _generate_name(config['name'], tname+" Attr name", ttype)
        except KeyError, ex:
            raise MissingTransformData("name", self.name)
        try:
            value = _generate_value(config['value'],tname+" Attr val",ttype)
        except KeyError, ex:
            raise MissingTransformData("value", self.name)

        ns = _generate_value(config.get('namespace'), tname+" Attr ns", ttype)
        pref = _generate_name(config.get('prefix'), tname+" Attr prefix", ttype)

        def impl(input, context, *args):
            out = {}
            out['name'] = name
            if isinstance(name, Transform):
                out['name'] = name(input, context)
            out['value'] = value
            if isinstance(value, Transform):
                out['value'] = value(input, context)

            if ns:
                out['namespace'] = ns
                if isinstance(ns, Transform):
                    out['namespace'] = ns(input, context)
            if pref:
                out['prefix'] = pref
                if isinstance(pref, Transform):
                    out['prefix'] = pref(input, context)

            return out

        return impl
        

class ToElementContent(Transform):

    def mkfn(self, config, engine):
        ttype = "xml.elementContent"

        attrs = None
        if config.has_key("attrs"):
            if not isinstance(config['attrs'], list):
                raise TransformConfigTypeError("attrs", "array", 
                                               type(config['attrs']), ttype)
            attrs = []
            for attr in config['attrs']:
                attr = _generate_object(attr, engine, 
                                        "{0} attr".format((self.name or '')),
                                        ttype)
                attrs.append(attr)
        
        children = None
        if config.has_key("children"):
            if isinstance(config['children'], str) or \
               isinstance(config['children'], unicode):
                children = [children]

            if not isinstance(config['children'], list):
                raise TransformConfigTypeError("children", "array or string", 
                                               type(config['children']), ttype)

            children = []
            for child in config['children']:
                child = _generate_object(attr, engine, 
                                         "{0} child".format((self.name or '')),
                                         ttype)
                children.append(child)
        
        def impl(input, context, *args):
            out = {}
            if attrs is not None:
                ol = []
                for attr in attrs:
                    if isinstance(attr, Transform):
                        attr = attr(input, context)
                    ol.append(attr)
                out['attrs'] = ol

            if children is not None:
                ol = []
                for child in children:
                    if isinstance(child, Transform):
                        attr = child(input, context)
                    ol.append(child)
                out['children'] = ol

            return out

        return impl

class toElement(Transform):

    def mkfn(self, config, engine):

        tname = self.name or '(xml)'
        ttype = "xml.element"

        try:
            name = _generate_name(config['name'], tname+" Element name", ttype)
        except KeyError, ex:
            raise MissingTransformData("name", self.name)

        ns = _generate_value(config.get('namespace'), tname+" El ns", ttype)
        pref = _generate_name(config.get('prefix'), tname+" El prefix", ttype)
        content = _generate_object(config.get('content'), engine, 
                                   tname+" content", ttype)
                                   
        def impl(input, context, *args):
            out = {}
            out['name'] = name
            if isinstance(name, Transform):
                out['name'] = name(input, context)
            out['content'] = content
            if isinstance(value, Transform):
                out['content'] = content(input, context)

            if ns:
                out['namespace'] = ns
                if isinstance(ns, Transform):
                    out['namespace'] = ns(input, context)
            if pref:
                out['prefix'] = pref
                if isinstance(pref, Transform):
                    out['prefix'] = pref(input, context)

            return out

        return impl

class toXML(Transform):
    """
    formats XML data into an output string
    """

    def mkfn(self, config, engine):
        try:
            transf = config['element']
        except KeyError, ex:
            raise MissingTransformData("element", self.name)

        if isinstance(transf, dict):
            transf = engine.make_transform(transf)
        elif isinstance(transf, str) or isinstance(transf, unicode):
            transf = engine.resolve_transform(transf)
        else:
            raise TransformConfigTypeError('transform', 'dict or str', 
                                           type(transf))

        def impl(input, context):

            root = transf(input, context)

            return self.format_element(root, context)

    def format_element(self, el, context, prefixes=None):

        if prefixes is None:
            prefixes = ScopedDict()

        hints = {}
        if el.get('hints'):
            hints = el['hints']
            context = Context(context)
            context.update(hints)

        indent = context('xml.indent', 0)
        step = context('xml.indent_step', 2)

        try: 
            opentag = (indent * ' ') + '<' + el['name']

            if el.get('content',{}).get('attrs'):
                opentag += ' '
                atts = self.format_atts(el['content']['attrs'], len(opentag1),
                                        context)
                opentag += atts

            if not el.get('content', {}).get('children'):
                opentag += '/>'
                if step >= 0:
                    opentag += '\n'
                return opentag

            else:
                opentag += '>'
                closetag = '</' + el['name'] + '>'

                maxlen = context('xml.max_line_length', 78)
                minlen = context('xml.min_line_length', 30)



                parts = [ opentag ]

                subcontext = Context(context)
                if step < 0:
                    # don't insert newlines
                    subcontext['xml.indent'] = 0
                    subcontext['xml.indent_step'] = -1
                else:
                    subcontext['xml.indent'] = indent + step
                    
                for child in el['content']['children']:
                    if isinstance(child, str) or isinstance(child, unicode):
                        parts.append(self.format_text(child, subcontext))
                    else:
                        parts.append(self.format_element(child, subcontext,
                                                         prefixes))

                parts.append(closetag)
                if step < 0:
                    return ''.join(parts)

                return '\n'.join(parts)

        except KeyError, ex:
            raise MissingXMLData.due_to(ex, self.name)

    def format_text(self, text, context=None):

        if context is None:
            context = Context()

        indent = context('xml.indent', 0)
        step = context('xml.indent_step', 2)
        maxlen = context('xml.max_line_length', 78)
        minlen = context('xml.min_line_length', 78)
        pad = context('xml.text_pad', 0)

        if step < 0:
            sp = pad * ' '
            return sp + text + sp

        sublen = maxlen-indent
        if sublen < minlen:
            sublen = minlen
        return map(lambda l: (indent * ' ') + l, textwrap.wrap(text, sublen))




class MissingXMLData(TransformApplicationException):

    def __init__(self, message, prop=None, input=None, context=None, name=None, 
                 cause=None):
        """
        construct the exception, providing an explanation.

        :argument str message: an explanation of what went wrong
        :argument str prop:  the name of the missing XML property 
        :argument input:    the JSON data that was being transformed
        :argument context:  the context at the point of the exception
        :argument str name:  the name of the transform being applied when
                             the exception occured.  If None, the exception 
                             is not known or not specific to a particular 
                             transform.
        :argument Exception cause:  the exception representing the underlying 
                                      cause of the exception.  If None, there 
                                      was no such underlying cause.
        """
        super(MissingXMLData, self).__init__(message,input,context,name,cause)
        self.prop = prop

    @classmethod
    def due_to(cls, cause, input=None, context=None, name=None):
        prop = None
        if isinstance(cause, KeyError):
            prop = cause.args[0]

        msg = "Missing XML data"
        if name:
            msg += " in '"+name+"' transform"
        msg += ": "
        msg += (prop or str(cause))
            
        return cls(msg, prop, input, context, name, cause)



        


        

        
        
